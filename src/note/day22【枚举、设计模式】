设计模式
    1. 装饰设计模式(Decorate)
        装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
    2. 单例设计模式(Singleton)
        1、创建类型的一种常用的软件设计模式  （也有可能一个线程中属于单例，如：仅线程上下文内使用同一个实例）
        2、单例模式的方法创建的类在当前进程中只有一个实例
        3、主要作用是保证在Java应用程序中,一个类Class只有一个实例存在
        4、节省内存
        5、饿汉式和懒汉式的区别
            饿汉式一上来就new对象,把对象加载进方法区
            懒汉式是先不new对象,等到有人使用时再判断是否为null,如果为null那么就new一个实例返回 懒汉式具有线程隐患
    3. 模板设计模式(Template)
        1、一个算法的骨架，将具体的算法延迟到子类中来实现
        2、优点：在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求
        2、缺点：如果算法骨架有修改的话，则需要修改抽象类
    4. 工厂设计模式(Factory)
        1、工厂设计模式，顾名思义，就是用来生产对象的
        2、角色：抽象产品类 具体产品类 抽象工厂类 具体工厂类
        3、工厂模式最大的优点就是：解耦
                解耦，就是将程序积木化就像我们玩的积木一样，各个积木可以组合在一起而形成一个形状，又可以拆分，又可以替换，
                因为基本上各个积木块都是独立的，只要他们之间的接口（形状）匹配，就可以灵活地组合在一起。
    5. 适配器设计模式(Adapter)
        1、解决接口与接口实现类之间继承矛盾问题（在编程实现里面：当一个类实现另一个接口的时候，有义务把接口中的方法都实现）
        2、模式特征
            使用抽象类分离了接口与接口实现。
            抽象类分摊接口中的方法。
            使得接口可以随意的选择接口中的方法来实现。
枚举
    1. 一个类有多个实例，但实例的个数不是无穷的，是有限个数的。我们称类中实例为枚举项！
    2. 枚举类的关键字是enum，而不是Enum，所有关键字都是小写的
    3. 在定义枚举项时，多个枚举项之间使用逗号分隔，最后一个枚举项后需要给出分号
    4. 不能使用new来创建枚举类的对象，因为枚举类中的实例就是类中的枚举项，所以在类外只能使用类名.枚举项。
    5. 在switch中，不能使用枚举类名称，在case中必须直接给出与d相同类型的枚举选项，而不能再有类型。
    6. 所有枚举类都默认是Enum类的子类，无需我们使用extends来继承。
    7. 方法
        1、compareTo(E e) ：比较两个枚举常量谁大谁小，比较的枚举常量在枚举类中声明的顺序
        2、name() ：返回枚举常量的名字；
        3、values() ：返回本类所有枚举常量；
        4、 valueOf(String name) ：通过枚举常量的名字返回枚举常量
        5、ordinal() ：返回枚举常量在枚举类中声明的序号，第一个枚举常量序号为0；
        6、toString() ：把枚举常量转换成字符串；
        7、equals(Object o) ：比较两个枚举常量是否相等；
        8、hashCode() ：返回枚举常量的 hashCode ；
    8. 枚举类的构造器：枚举类构造器默认都是private修饰 因为枚举类的实例不能让外界来创建
    9. 枚举类的成员：枚举类和正常的类一样，可以有实例变量，实例方法，静态方法等等，只不过它的实例个数是有限的，不能再创建实例而已。
    10.枚举类中的抽象方法：
        1、在创建每个枚举项时使用匿名内部类都必须去重写它
        2、枚举项(){抽象方法}
        3、无法把枚举类声明为抽象类，但可以声明成员方法为抽象方法。

