标识符：程序中自定义的名称
    1.不能以数字开头，符合只能写_$
    2.不能使用关键字
    3.类名使用驼峰命名 每个单词首字母大写
    4.方法名使用驼峰命名 第一给单词首字母小写
    5.包名全部小写
    6.名字要有语义化 英文不会拼音凑

常量：在程序运行过程中不可变的量
变量：在底层开辟一个小空间 存放是一个不确定的数据
数据类型：
    1.基本数据类型：
        1、整型：
                byte    字节型
                short   短整型
                int     整形      默认
                long    长整型
        2、浮点型：
                float   单精度             小数位7
                double  双精度     默认     小数位15
        3、字符型：char
        4、布尔型：true、false
    2.引用数据类型：字符串 枚举、数组......

java创建变量：java是强类型语言
    数据类型 变量名 = 数据;
    1.先创建后赋值
    2.创建直接赋值
    注意事项：
        1、变量没有赋值不能使用
        2、变量可以重复赋值，后面赋值会覆盖前面的值
        3、变量一次性只能存放一个数据
        4、变量只定义在{}有效
        5、变量名不能重复
        6、右侧数据不能超过数据类型最值

进制：是一种计数的方式
    整数表示形式四种
        二进制：0 1     0开头
        八进制：0-7     0x开头
        十进制：0-9
        十六进制：0-9A-F
    结论：
        一个八进制数=三个二位进制位
        一个十六进制=四个二位进制位
        1010 - 1000
        101-101-100
         2   5   4   0254  (8进制)
        1010-1100
         10   12   0xAC  (十六进制)

数据类型转换：
    1.自动类型转换(隐式)
        不同类型发生数字运算时，进行变量提升 规制从小到大
        byte<short<char<int<long<float<double
    2.强制类型转换(显式)
        小的数据类型 变量 = (大的数据类型)变量

+号 数字相加 字符相连
不同类型使用复合赋值运算符 会自动强制类型转换
三元表达式：必须要有结果 结果必须要被使用
ASCII码：48～57为0到9  65～90为26个大写英文字母   97～122号为26个小写英文字母

if:当if大括号里面只有一条语句  大括号可以省略  if()语句;
for循环扩展：
    格式：   标记:for(;;){}
    break和continue后可以加标记 结束循环或者跳过指定循环  break/continue 标记

方法的重载：一个类中可以允许存在一个以上重名的方法，只要参数列表不一样
    参数列表不一样：个数、数据类型、顺序不一样
    方法的重载和返回值类型以及权限修饰符没有关系，只和参数列表有关系

直接打印数组输出的是数组的地址值
    [   表示这是一个数组
    I   表示数组中的数据是int
    @   没有意义 连接符
    xxxxx   哈希值 地址值

方法要运行必须进栈(压栈)，运行完毕后要出栈(弹栈)

字符串：
    startsWith("指定字符")：判断是否以指定字符串开头
    endsWith("指定字符")：判断是否以结尾字符串结尾

类和对象的关系：类是对象的描述，对象是类的实体
成员变量和局部变量的区别：
    成员变量：
        1、定义在类中方法外，这个类都可以使用
        2、存在堆内存的对象中
        3、有默认值，不赋值也可以使用
        4、随着对象的创建而创建，随着对象的销毁而释放
    局部变量：
        1、定义在方法中、局部代码块中，只在所属区域有效
        2、存在栈内存的方法中
        3、没有默认值，不赋值不可以使用
        4、随着方法的调用而存在，随着方法的结束而释放

导包：java.lang包下的类不需要导入

Scanner(InputStream source)构造一个新的Scanner,他生成的值是从指定的输入流扫描的。
    InputStream source：固定写法-System.in 系统输入指的是键盘录入的数据
    成员方法：
        String next():  获取键盘输入的信息 输入信息后的所有空格、Tab、enter都会视为结束符
        int nextInt():  获取键盘输入的数字
        String nextLine():  获取键盘输入的信息 只有enter才是结束符 可以保留空格
java.util.Random
    Random()    创建一个新的随机数生成器
    nextInt(int n) 返回一个伪随机数，随机数生成器序列在0和指定值n(不包含n)均匀分布的int值

java.util.ArrayList<E> 集合
    特点：
        1、大小可变数组的实现
        2、<E>(泛型)：指的是当前集合中存放的统一都是什么类型的。泛型只能是引用类型
        3、直接打印集合，不是地址值。打印的集合中的元素，没有元素则[]
        4、创建集合时，右侧的<>里面的泛型在jdk1.7后可以省略不写，但是<>不能省略
     构造方法：
        ArrayList<E>() 构造有一个初始容量为10的空列表
     成员方法：
        add(e) 将指定的元素添加到此列表的尾部
        indexOf(Object o)  返回此列表中首次出现的指定元素的索引，没有则返回 -1。
        lastIndexOf(Object o)  返回此列表中最后一次出现的指定元素的索引，没有则返回 -1。
        remove(index) 移除此列表中指定位置上的元素 返回被删除的元素
        get(index) 返回此列表中指定位置上的元素
        size() 返回此列表中的元素数
        set(index,e) 用指定的元素替代此列表中指定位置上的元素。
     集合中存储基本数据类型，泛型为基本数据类型的包装类(将一个基本数据类型包装成一个引用类型)
        int》》》Integer  char》》》Charater
     重点：
        底层是数组
        扩容对一次0 第二次10  之后的扩容都是1.5倍 返回MAX_ARRAY_SIZE  当扩容超过最大容量时 返回int类型的最大值
        查询快，增删慢

java.lang.String(常量)
    String类代表字符串。java程序中的所有字符串字面值都作为此类的的实例实现
    所有用引号引起来的都是字符串
    特点：
        1、字符串都是常量，它们的值在创建之后不能更改
        2、因为String对象是不可变的，所以可以共享
    构造方法：String string = ......
            1、直接用双引号引起来的也是一个字符串对象
            2、new String() 创建一个空的字符串对象
            3、new String("original") 根据字符串来创建一个字符串对象
            4、new String(char[]) 通过字符数组来创建字符串对象
            5、new String(byte[]) 通过字节数组来构造新的字符串对象
            6、new String(byte[], int index, int length) 通过字节数组一部分来构造新的字符串对象
    注意事项:
            1.==  基本数据类型比较的是内容，引用类型比较的是地址值
            2.如果你发现字符串改变了，那么它一定是创建了一个新的字符串
            3.变量.成员方法(常量/变量)  不推荐
    strObj.toCharArray() 将字符串转换为    char数组
    strObj.getBytes()    将字符串转换为    字节数数组
    strObj.split("str") 将字符串用指定字符分割成字符串数组
    成员方法：
            s1.equals(s2) 比较字符串的内容是否相同  相等true 不等false
            s1.equalsIgnoreCase(s2)  比较字符串的内容是否相同,忽略大小写  相等true 不等false
            strObj.toLowerCase() 转小写
            strObj.toUpperCase() 转大写
            strObj.length() 返回此字符串的长度。
            strObj.concat(str)  将指定的字符串连接到该字符串的末尾
            strObj.chatAt(index)  返回指定索引处的 char 值
            strObj.indexOf(str)  返回指定子字符串第一次出现在该字符串内的索引。
            strObj.lastIndexOf(str)  返回指定子字符串最后一次出现在该字符串内的索引。
            strObj.substring(sIndex，eIndex) 从sIndex到eIndex截取字符串。含sIndex，不含eIndex。
            strObj.startsWith(str，[sIndex]) 判断是否以指定的      始。sIndex 查找开始位置
            strObj.endsWith(str) 判断是否以指定的子字符串结束
            strObj.replace(str,replaceStr) 将指定字符替换

static关键字：静态  优先于所有对象的执行
    可以修饰成员变量和成员方法，一旦用static修饰后的成员变量和成员方法就只属于类的
    static修饰的成员变量叫做静态变量
    static修饰的成员方法叫做静态方法
    访问静态变量和静态方法格式：
        对象名.静态变量/静态方法  不推荐
        类名.静态变量/静态方法
    静态方法：
        在本类中访问本类的静态方法可以省略类名不写
        静态方法中不能this this代表对象 静态优先于所有对象
    静态代码块：
        static{

        }
        特点：
            1.类中方法外
            2.优先于构造方法执行
            3.在第一次创建对象时，只会执行唯一的一次

java.util.Arrays 数组工具列，包含操作数组的一些静态方法
    toString(int[]): 返回指定数组内容的字符串表示形式
    sort(int[]): 对指定数组进行排序(升序) 整形按数字 字符或字符串按大小写字母
    copyOf(arr,length)  对数组进行复制 长度为length

面向对象的三大特征：封装 继承 多态
    继承性：(共性抽取)
        将多个子类(派生类)相同的属性和行为抽取出来形成一个单独的父亲(超类/基类),子类继承父类，可以拥有
        父类所有非私有的属性、行为、方法
        继承是多态的前提，没有的继承就没有多态
    定义父类的格式：一个普通的类      public class 父类的名称{}
    定义子类的格式：public class 子类的名称 extends 父类的名称{}
    在继承关系中，成员变量重名时，创建子类访问成员变量：
        1、直接访问 子类.成员变量
            等号左边是谁就优先用谁，没有则向上找父类，父类没有编译报错
        2、间接访问 子类.成员方法
            这个方法属于谁，就优先用谁，没有则向上找父类，父类没有编译报错
    区分子类成员方法中重名的三种变量：
        局部变量         直接写变量名  通过就近原则查找
        子类的成员变量     this.成员变量
        父类的成员变量     super.成员变量
    在继承关系中，成员方法重名时，创建子类访问成员方法
        创建的对象时谁就优先用谁，没有则向上找父类，父类没有编译报错
    在继承关系中，父类构造方法访问特点：
        1、子类构造方法中会默认隐含赠送一个super() 调用父类无参构造
        2、子类构造方法可以访问父亲重载构造方法
        3、调用父类的构造方法super()必须时在子类构造方法中第一行语句
        4、如果手动写了super(参数) 调用父类有参构造
        5、只有子类的构造方法才能调用父类的构造方法
    super的用法：
        调用父类的成员变量 super.成员变量
        调用父类的成员方法 super.成员方法
        调用父类的构造方法 super([参数])  必须是构造方法
    this的用法：
        调用父类的成员变量 this.成员变量
        调用父类的成员方法 this.成员方法
        调用父类的构造方法 this([参数])
    覆盖重写(override)  -----重载(overload)  方法名相同，参数列表不同
        在继承关系中，方法名相同，参数列表也相同 就叫做方法的覆盖重写
        特点：创建的是子类对象优先用子类，子类没有找父类
        注意事项：
            1、注解：@override 卸载方法上面，用于话北侧该方法是否是正确的覆盖重写
                如果本身就是正确的覆盖重写，不加注解也可以
            2、子类方法的返回值必须小月等于父类方法的返回值范围
                Object类是所有类的最高父类
            3、子类方法的权限修饰必须大于等于父类方法的权限修饰符
                public protected (default) private      (default):不是关键字，而是什么都不写
        使用场景：
            在不修改一类的源代码时，相对这个类的一些功能加强时，就可以继承这个类，
            对这个类的某一个方法覆盖重写

接口：引用类型 是方法的集合 接口的内部主要就是封装了方法
    1.接口不是类 不能用class
    2.类与接口：
        类与接口的关系为实现关系
        接口不能new(实例化)
        实现类需要重写接口的所有的抽象方法 如果不重写 则必须声明成抽象类
        实现类可以直接调用父接口的默认方法
        类单继承，多实现  接口可以多继承接口
    2.默认方法 必须有方法体  如果多个父接口中有相同名称的默认方法，则子类必须重写
    3.静态方法只能自己调用
    4.接口中的方法默认都是抽象方法，可以省略修饰符public abstract
    5.私有方法：只有默认方法可以调用。
    6.私有静态方法：默认方法和静态方法可以调用。
        私有的方法是对默认方法和静态方法的辅助。
    7.接口中不能有成员变量，但是可以有常量
    8.父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法
    9.接口只能有常量：常量名全部大写
            public final static 数据类型 常量名 = 值
            常量名如果有多个单词构成，则_分隔
    10.接口中,没有构造方法,没有静态代码块

匿名内部类：返回的是接口的子实现类，而且没有名字

equals：
    1.实际调用的是==  比较地址值
    2.基本类型没有equals 只有包装类型和封装类型有
    3.大多数类会重写equals，重写之后大多是比较值

列表结构：单向 双向  单向环形    双向环形

Set集合去重原理：
    往HashSet添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值
    如果hash值不相同，说明是一个新元素，直接存储在这个位置上；
    如果hash值相同，然后判断equals,返回true，说明元素已经存在，不存,返回false,说明不是同一个元素，存储。
    相同哈希值的元素就这样存储在同一个哈希桶中，用链表连接，如果超过链表的阈值（8），则转换成红黑树存储数据。
重写hashCode()一定要重写equals()

Map集合
    key不允许重复，value可以重复
    无序
    key可以为空、null、""  value，也可以为空、null、""

异常Exception
    1.异常的根类是Throwable ，其下有两个子类：Error与Exception，平常所说的异常指Exception 。
    2.Error和Exception和的区别
        Error:严重错误Error，无法通过处理的错误，只能事先避免
        Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的
    3.异常(Exception)的分类:
        编译时期异常：checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败
        运行时期异常：runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测
    4. 异常的处理
        throw：抛出异常
            throw new 异常类名("提示错误信息");
            用在方法内,用来抛出一个异常对象,将这个异常对象传递到调用者处,并结束当前方法的执行。
        throws：声明异常
            修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{ }
            如果方法内通过throw抛出了编译时异常,而没有捕获处理那么必须通过throws进行声明,让调用者去处理
            用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常
            谁调用谁处理异常
        try…catch:捕获异常
            try{ 可能会出现异常的代码 }catch(异常类型A e){ 处理异常的代码 }catch(异常类型B e){处理异常的代码 }
            try规定里面放的是可能发生异常的代码，不会发生异常的代码不能放进try里面
            catch里面的代码是捕获到了异常才会被执行
            e.getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因)
            e.printStackTrace():打印异常的跟踪栈信息并输出到控制台  推荐使用
            try{ }catch(Exception e){}finally{}
                在finally代码块中存放的代码都是一定会被执行的。
                如果finally有return语句,永远返回finally中的结果
            注意：
                1. 多个异常分别处理。
                2. 多个异常一次捕获，多次处理。
                3. 多个异常一次捕获一次处理。
                4. 子类在上面，父类在下面
        如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常
        父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。子类产生异常，只能捕获处理，不能声明抛出
    5.常见的异常
        1、NullPointerException：空指针异常
        2、ArithmeticException：算术异常
        3、ArrayIndexOutOfBoundsException：数组下标越界异常

线程
    并发：指两个或多个事件在同一个时间段内发生。
    并行：指两个或多个事件在同一时刻发生（同时发生）。
    1.所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务
    2.定义Thread类的子类并重写该类的run()方法，该方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。
    3.调用线程对象的start()方法来启动该线程，不是调用run()方法
    5.Runnable接口
        定义Runnable接口的实现类并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
        Runnable的实例，此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
        Thread类实际上也是实现了Runnable接口的类
        Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的
    6.多线程原理：
        1、程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用
           的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。
        2、多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。
        3、在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。
           因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM,
           每一个JVM其实在就是在操作系统中启动了一个进程。
    7.Thread和Runnable的区别
        如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。
        实现Runnable接口比继承Thread类所具有的优势:
            1. 适合多个相同的程序代码的线程去共享同一个资源。
            2. 可以避免java中的单继承的局限性。
            3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
            4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类
    8.线程的操作
        1、sleep(long millis) ：让当前线程睡眠指定的毫秒数
            sleep()中指定的时间是线程不会运行的最短时间
            sleep()方法不能保证该线程睡眠到期后就开始立刻执行
            sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态
            sleep不会释放锁
        2、join() :
            指定线程调用该方法,线程执行权交给该线程,当前线程必须等该线程执行完后才执行但有可能被其他线程抢去CPU执行权.
            join(long millis): 让线程执行millis毫秒,再执行其他线程
        3、setDaemon(boolean on)：设置线程是否为守护线程
            当用户线程(非守护线程)执行完毕时，守护线程也会停止执行但由于CPU运行速度太快，当用户线程执
            行完毕时，将信息传递给守护线程，会有点时间差，而这些时间差会导致还会执行一点守护线程
        4、setPriority(int newPriority) ：设置线程的优先级，线程优先级默认为5 最高为10 最低为1
            线程优先级高的,更容易让线程在就绪状态中抢到线程执行权
            但是线程优先级高 也不一定执行的就多.也有可能优先级低的优先执行完毕
        5、yield() ：线程礼让
            告知当前线程可以将执行权礼让给其他线程，礼让给优先级相对高一点的线程，但仅仅是一种告知,
            并不是强制将执行权转让给其他线程.也有可能下次的执行权还在原线程这里
            如果想让原线程强制让出执行权 可以使用join()方法
        6、wait:等待
            wait() 无限等待 一定要被唤醒
            wait(long millis) 让当前线程进入等待状态 等待指定毫秒数  可以提前被唤醒
                让当前线程进入等待状态(并不是当前线程对象来调用,而是当前锁对象来调用)
            调用wait()之后释放当前锁,并且让当前锁对象中对应的线程阻塞
            wait():方法必须配合同步锁使用,同步锁中的对象是谁 那么就用谁来调用wait方法
            因为wait需要释放锁，所以必须在synchronized中使用，没有锁时使用会抛出IllegalMonitorStateException
        7、notify() ：随机唤醒一条此锁对象对应线程中的一条
                notify()也是锁对象来调用,并不是当前线程对象调用
                notifyAll()：唤醒当前锁对象对应的所有线程(效率低)
        8、调用wait和notify方法需要注意的细节
            1. wait方法与notify方法必须要由同一个锁对象调用。
            2. wait方法与notify方法是属于Object类的方法的。
            3. wait方法与notify方法必须要在同步代码块或者是同步函数中使用

    9.同步代码块 synchronized
        synchronized(同步锁){ 需要同步操作的代码 }
        同步锁：
            1. 锁对象 可以是任意类型。
            2. 多个线程对象 要使用同一把锁。
        在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(阻塞 cpu抢用权)
        Java中凡是加锁的效率低下

线程池
    线程池可以理解为是一个可以容纳多个线程的容器 其中的线程可以反复使用，通过使用线程池对象的submit()去开启运行一个线程
    省去了频繁创建线程对象的操作
    合理的使用线程池可以有以下优点
        1.降低资源消耗
        2.提高响应速度
        3.提高线程的可管理性
    1.固定线程池：Executors.newFixedThreadPool(int nThreads);
        创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；
        如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)
        适用：执行长期的任务，性能好很多
        线程池对象.submit(Runable接口) 开启运行一个线程
    2.可缓存线程池：Executors.newCachedThreadPool();
        当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，
        若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；
        若池中线程空闲时间超过指定大小，则该线程会被销毁。
        适用：执行很多短期异步的小程序或者负载较轻的服务器
    3.单线程池：newSingleThreadExecutor()
        创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)
        适用：一个任务一个任务执行的场景

计数器：CountDownLatch
    它是一个同步工具类，用来协调多个线程之间的同步 实现多个线程开始执行任务的最大并行性
    await()方法 在run方法内对线程阻塞，只要计数器的值变成0，就立马放行
    countDown();  计数器减一

File类
    该类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。
    1. 构造方法：
        1、File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例
            无论该路径下是否存在文件或者目录，都不影响File对象的创建
    2. 获取：
        1、 getAbsolutePath() ：返回此File的绝对路径名字符串。
        2、 getPath() ：将此File转换为路径名字符串。
        3、 getName() ：返回由此File表示的文件或目录的名称。
        4、 length() ：返回由此File表示的文件的长度。 如果File对象是目录，则返回值未指定 0
    3. 判断：
        1、 exists() ：此File表示的文件或目录是否实际存在。
        2、 isDirectory() ：此File表示的是否为目录。
        3、 isFile() ：此File表示的是否为文件。
    4. 创建删除：
        1、 createNewFile() ：当且仅当具有该文件不存在时，才会创建一个新的空文件。
        2、 mkdir() ：创建一个目录
        3、 mkdirs() ：可以单个创建目录，也可以创建多级目录
        4、 delete() ：删除文件或目录。如果此File表示目录，则目录必须为空才能删除
    5. 遍历：
        1、listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。
            必须是实际存在的目录，否则返回null，无法进行遍历。

递归:
    分类: 直接递归和间接递归
        直接递归称为方法自身调用自己。
        间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。
        注意事项：
            1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出
            2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出
            3.构造方法,禁止递归

IO流
    1. IO是一种数据的流动，按照流动的方向，以内存为基准流向内存是输入流，流出内存的是输出流
    2. 根据数据的流向分为：输入流和输出流。
            输入流 ：把数据从 其他设备 上读取到 内存 中的流。
            输出流 ：把数据从 内存 中写出到 其他设备 上的流。
    3. 格局数据的类型分为：字节流和字符流。
            字节流 ：以字节为单位，读写数据的流。
            字符流 ：以字符为单位，读写数据的流
    4. 完成流的操作时，必须调用close()方法，释放系统资源。 流的关闭原则：先开后关，后开先关。
    5. 字节流:
        1.一切文件数据在存储时，都是以二进制数字的形式保存，都一个一个的字节，传输时一样如此。
        2.字节流可以传输任意文件数据。在操作流的时候，无论使用什么样的流对象，底层传输的始终为二进制数据。
        3.创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出 FileNotFoundException 。
        4. 字节输出流 OutputStream
            1. 抽象类,表示字节输出流的所有类的超类(父类、基类)，将指定的字节信息写出到目的地。
            2. FileOutputStream 类是文件输出流，用于将数据写出到文件
            3. 构造方法
                new FileOutputStream(File file) ：创建文件输出流以写入由指定的File对象表示的文件。
                new FileOutputStream(String name) ： 创建文件输出流以指定的名称写入文件。
            4. 基本共性功能方法
                1、write(int b) ：将指定的字节输出流。
                2、write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流
                3、write(byte[] b, int off, int len) ：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。
                4、数据追加续写:在构造方法中再传入一个boolean类型的值， true表示追加数据， false表示清空原有数据
                5、写出换行 换行符号是 \r\n\
        5.  字节输入流 InputStream
            1. 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。
            2. FileInputStream 类是文件输入流，从文件中读取字节
            3. 构造方法
                FileInputStream(File file) ：
                    通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系 统中的 File对象 file命名。
                FileInputStream(String name) ：
                    通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件 系统中的路径名 name命名
            4. 基本共性功能方法
                 1、int read() ： 从输入流读取数据的下一个字节。
                 2、read(byte[] b) ： 从输入流中读取一些字节数，并将它们存储到字节数组b中。 读取到末尾时，返回 -1
                 3、write(byte[] b, int off, int len) ：从指定的字节数组读取off到len的字节，读取到此输入流。
                    使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率
    6. 字符流：
        1. 字符流类，以字符为单位读写数据，专门用于处理文本文件。
        2. 你创建一个流对象时，必须传入一个文件路径
        3. 字符输入流 Reader
            1.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。
            2. 构造方法
                FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区
                    字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8
                    字节缓冲区：一个字节数组，用来临时存储字节数据。
                    FileReader(File file) ： 创建一个新的 FileReader ，给定要读取的File对象。
                    FileReader(String fileName) ： 创建一个新的 FileReader ，给定要读取的文件的名称。
            3. 基本共性功能方法
                1、read() ： 从输入流读取一个字符的数据，提升为int类型。读取到文件末尾，返回 -1
                2、read(char[] cbuf) ： 从输入流中读取字符到数组中，返回读取到的有效字符个数， 读取到末尾时，返回 -1
        4.字符输入流 Reader
            1.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。
            2.构造方法
                FileWriter 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。
                FileWriter(File file) ： 创建一个新的 FileWriter，给定要读取的File对象。
                FileWriter(String fileName) ： 创建一个新的 FileWriter，给定要读取的文件的名称。
            3.基本共性功能方法
                1、write(int c) 写入单个字符。
                2、write(char[] cbuf) 写入字符数组。
                3、write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len 写的字符个数。
                4、write(String str) 写入字符串。
                5、write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个 数。
                6、flush() 刷新该流的缓冲。 关闭流前一定要使用该方法
    7.字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流

属性集 Properties
    1. 一个持久的属性集。它使用键值结构存储数据，每个键及其 对应值都是一个字符串。
    2. setProperty(String key, String value) ： 保存一对属性
    3. getProperty(String key) ：使用此属性列表中指定的键搜索属性值。
    4. stringPropertyNames() ：所有键的名称的集合。
    5. load(InputStream inStream) ： 从字节输入流中读取键值对。
        文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔

缓冲流
    1. 缓冲流也叫高效流，是对4个基本的 FileXxx 流的增强 所以也是4个流
    2. 基本原理
        在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。
    3. 按照数据类型分类
        字节缓冲流： BufferedInputStream ， BufferedOutputStream
        字符缓冲流： BufferedReader ， BufferedWriter
    4. 字节缓冲流
        1、构造方法
            public BufferedInputStream(FileInputStream in) ：创建一个 新的缓冲输入流。
            public BufferedOutputStream(FileOutputStream out) ： 创建一个新的缓冲输出流。
        2、字节缓冲流的基本方法与普通字节流调用方式一致
    5. 字符缓冲流
            1、构造方法
                public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。
                public BufferedWriter(Writer out) ： 创建一个新的缓冲输出流。
            2、除了与普通字符流调用方式一致,还具备的特有方法
                1、BufferedReader: readLine() : 读一行文字。
                2、BufferedWriter: newLine() : 写一行行分隔符,由系统属性定义符号

转换流
    1. 字符编码
        1. 计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。
           将字符存储到计算机中，称为编码
           将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码
        2. 字符编码 Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则
            编码表:生活中文字和计算机中二进制的对应规则
    2. 字符集
        1. 也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。
        2. 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。
           常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。
           1、ASCII字符集:
                用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。
                基本的使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。
           2、GBxxx字符集：  GB就是国标的意思，是为了显示中文而设计的一套字符集。
                GB2312：
                    简体中文码表。一个小于127的字符的意义与原来相同。两个大于127的字符连在一起时，就表示一个汉字，
                    大约了包含7000多个简体汉字，此外数学符号、 罗马希腊的字母、日文的假名们都编进去了，
                    在ASCII里本来就有的数字、标点、字母都重新编了两个字节长的编码，这就是常说的"全角"字符，
                        而原来在127号以下的那些就叫"半角"字符了。
                GBK：最常用的中文码表。
                    是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，
                    完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。
                GB18030：最新的中文码表。
                    收录汉字70244个，采用多字节编码，每个字可以由1个、2个 或4个字节组成。
                    支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。
           3、Unicode字符集
                1、Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。
                2、最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。
                3、UTF-8编码
                    1.用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。
                    2.所有互联网协议都必须支持UTF-8编码。
                    3.编码规则：
                        1、 128个US-ASCII字符，只需一个字节编码。
                        2、 拉丁文等字符，需要二个字节编码。
                        3、 大部分常用字（含中文），使用三个字节编码。
                        4、 其他极少使用的Unicode辅助字符，使用四字节编码。

InputStreamReader类
    1. 是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。也可以接受平台的默认字符集。
    2. 构造方法
        InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。
        InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。
OutputStreamWriter类
    1. 是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。也可以接受平台的默认字符集。
    2. 构造方法
        OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。
        OutputStreamWriter(OutputStream in, String charsetName) : 创建一个指定字符集的字符流。

序列化
    1. 用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。
       字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。
    2. 字节序列可以从文件中读取回来，重构对象，对它进行反序列化
    3. ObjectOutputStream
        1、将Java对象的原始数据类型写出到文件,实现对象的持久存储。
        2、构造方法
            public ObjectOutputStream(OutputStream out) ： 创建一个指定OutputStream的ObjectOutputStream。
        3、序列化操作
          1. 一个对象要想序列化，必须满足两个条件:
                该类必须实现Serializable接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。
                该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient关键字修饰。
          2.  writeObject (Object obj) : 将指定的对象写出。
    4. ObjectInputStream 反序列化流，
        1、 将之前使用ObjectOutputStream序列化的原始数据恢复为对象
        2、 对于JVM可以反序列化对象，它必须是能够找到class文件的类。
                找不到该类的class文件，则抛出一个ClassNotFoundException 异常。
        3、 找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常
                异常原因：
                        1. 该类的序列版本号与从流中读取的类描述符的版本号不匹配
                        2. 该类包含未知数据类型
                        3. 该类没有可访问的无参数构造方法
        5、 Serializable 接口给需要序列化的类，提供了一个序列版本号。
                serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。
        4、 构造方法
             public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。

打印流 PrintStream 类
    1.该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。
    2.构造方法 PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。
    3.改变打印流向：设置系统的打印流流向 System.setOut(PrintStream ps);



















